# -*- coding: utf-8 -*-
"""PythonNetworkXProject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MgsCVFPgLAOT4fHMs5HFPEvT4QtdcjVW

#Python NetworkXProject
YUNUS_CAN_DUMAN_05240000217
"""

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
from itertools import combinations

"""###Defining Person Class and Persons"""

class Person:
  def __init__(self, name, job):
    self.name = name
    self.job = job
  def getName(self):
    return self.name
  def getJob(self):
    return self.job
  def __repr__(self):
    return f"{self.name}\n({self.job})"

olivia = Person("olivia","doctor")
celine = Person("celine","engineer")
winston = Person("winston","politician")
chloe = Person("chloe","architect")
john = Person("john","mechanic")
jack = Person("jack","professor")
personList = [olivia,celine,winston,chloe,john,jack];

"""###Adding items to networkX Graph"""

G=nx.Graph()
G.add_nodes_from(personList)

G.add_edge(john, olivia, weight=7)
G.add_edge(john, jack, weight=9)
G.add_edge(john, chloe, weight=7)

G.add_edge(olivia, celine, weight=8)
G.add_edge(olivia, jack, weight=4)

G.add_edge(jack, celine, weight=5)
G.add_edge(jack, chloe, weight=5)
G.add_edge(jack, winston, weight=7)

G.add_edge(celine, winston, weight=6)

G.add_edge(chloe, winston, weight=11)

"""###Visualization"""

pos = nx.spring_layout(G, seed=42)

plt.figure(figsize=(10, 7))


nx.draw_networkx_nodes(G, pos, node_size=2000, node_color='lightblue')


nx.draw_networkx_edges(G, pos, width=2)


nx.draw_networkx_labels(G, pos, font_size=10, font_weight='bold')


edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=12)

plt.title(" Phone Network (via. NetworkX)", fontsize=15)
plt.axis('off')
plt.show()

"""###Finding Shortest Path"""

print("Shortest Path Using Dijkstra")

print("-" * 85)

print(f"{'PAIR ':<20} | {'DISTANCE':<10} | {'PATH '}")
print("-" * 85)

for p1, p2 in combinations(G.nodes(), 2):
    distance = nx.dijkstra_path_length(G, source=p1, target=p2, weight='weight')
    path = nx.dijkstra_path(G, source=p1, target=p2, weight='weight')


    path_str = " -> ".join([p.name for p in path])
    pair_str = f"{p1.name} - {p2.name}"


    print(f"{pair_str:<20} | {distance:<10} | {path_str}")

"""#### What if we remove the Jack?"""

G.remove_node(jack)

print(f"{'PAIR ':<20} | {'DISTANCE':<10} | {'PATH '}")
print("-" * 85)


for p1, p2 in combinations(G.nodes(), 2):
    try:
        distance = nx.dijkstra_path_length(G, source=p1, target=p2, weight='weight')
        path = nx.dijkstra_path(G, source=p1, target=p2, weight='weight')

        path_str = " -> ".join([p.name for p in path])
        pair_str = f"{p1.name} - {p2.name}"

        print(f"{pair_str:<20} | {distance:<10} | {path_str}")

    except nx.NetworkXNoPath:
        print(f"{p1.name} - {p2.name:<17} | {'YOK':<10} | Path can't be founded")

"""Jack (Prof.) was at the very center of the graph and provided the link (bridge) between many people. When he was removed, people were forced to use longer, alternative paths to reach each other.

Typically, Jack acts as a "keystone" (hub). The distance between Chloe and Celine, in particular, has increased significantly (from 10 to 17) because they now have to go through Winston instead of Jack.

###DFT (DFS) and BFT (BFS) traversal process starting from a given vertex number.
"""

# Select a starting node for the traversal algorithms
start_node = john

# --- Breadth-First Search (BFS) ---
# traverses the graph layer by layer (neighbors first)
bfs_tree = nx.bfs_tree(G, source=start_node)
bfs_nodes = list(bfs_tree)

# --- Depth-First Search (DFS) ---
# traverses the graph by going as deep as possible along each branch
dfs_nodes = list(nx.dfs_preorder_nodes(G, source=start_node))

# --- Printing the Results ---
print("-" * 60)
print(f"Starting Node: {start_node.name}")
print("-" * 60)

# Helper lambda to format the list of Person objects into a string of names
format_path = lambda nodes: " -> ".join([person.name for person in nodes])

print(f"BFS (Breadth-First) Order : {format_path(bfs_nodes)}")
print(f"DFS (Depth-First) Order   : {format_path(dfs_nodes)}")
print("-" * 60)

"""###QUESTION:
  How do we find the "Mechanic"  reachable in the shortest amount of time, considering that each person has a specific probability of not answering the phone?

####Proposed Method
We model the problem using a Directed Graph (DiGraph). Since there is a probability ($P$) of success for each connection, we must calculate the "Expected Time" (Cost) for each edge rather than using the raw time values.The algorithm uses the following formula to adjust the weights:

$$\text{Expected Time} = \frac{\text{Original Time}}{\text{Probability of Target Answering}}$$

Logic:This formula mathematically increases the "cost" of edges where the recipient is unreliable (has a low probability of answering). This forces Dijkstra's Algorithm to prefer paths that are more reliable (higher probability), even if the nominal time is slightly longer, ensuring the most efficient "expected" outcome.
"""

# 1. Person Class Definition
class Person:
    def __init__(self, name, job, probability=1.0):
        self.name = name
        self.job = job
        # Probability of this person answering the phone (0.0 to 1.0)
        self.probability = probability

    def __repr__(self):
        return f"{self.name} ({int(self.probability*100)}%)"

# 2. Creating Person Instances (Nodes)
john = Person("john", "mechanic", probability=1.0)
olivia = Person("olivia", "doctor", probability=0.9)
celine = Person("celine", "engineer", probability=0.8)
jack = Person("jack", "professor.", probability=0.9)
chloe = Person("chloe", "architect", probability=0.7)
winston = Person("winston", "politician", probability=0.5)

# 3. Creating a Directed Graph
G = nx.DiGraph()

raw_edges = [
    (john, olivia, 7), (john, jack, 9), (john, chloe, 7),
    (olivia, celine, 8), (olivia, jack, 4),
    (jack, celine, 5), (jack, chloe, 5), (jack, winston, 7),
    (celine, winston, 6),
    (chloe, winston, 11)
]

# 4. Adding Edges with "Expected Time" Calculation
for p1, p2, time in raw_edges:
    # Cost depends on p2's probability of answering
    weight_p1_to_p2 = time / p2.probability
    G.add_edge(p1, p2, weight=weight_p1_to_p2)

    # Cost depends on p1's probability of answering
    weight_p2_to_p1 = time / p1.probability
    G.add_edge(p2, p1, weight=weight_p2_to_p1)

# 5. Algorithm to Find the Nearest Mechanic
def find_best_mechanic(graph, start_node):
    lengths, paths = nx.single_source_dijkstra(graph, source=start_node, weight='weight')

    best_mechanic = None
    min_expected_time = float('inf')

    for node, time in lengths.items():
        if node.job == "mechanic":
            if time < min_expected_time:
                min_expected_time = time
                best_mechanic = node

    return best_mechanic, min_expected_time, paths.get(best_mechanic)

# --- EXECUTION ---
for start_person in [john, olivia, celine, jack, chloe, winston]:

      target, time, path = find_best_mechanic(G, start_person)

      print("-" * 60)
      print(f"Start Node: {start_person}")
      print("-" * 60)

      if target:
          path_names = " -> ".join([p.name for p in path])
          print(f"Found Target  : {target.name} (Job: {target.job})")
          print(f"Expected Time : {time:.2f} minutes")
          print(f"Optimal Path  : {path_names}")
      else:
          print("No Mechanic found.")
      print("-" * 60)

"""### What is a Knowledge Graph (KG)? Why is it important? What are the Application Areas of Knowledge Graphs?

What is a Knowledge Graph (KG)?
A Knowledge Graph (KG) is a structured representation of facts, consisting of entities, relationships, and semantic descriptions. It organizes data in a graph structure (like the one you built with John and Olivia) but adds meaning (semantics) to the connections.

In a KG, data is stored as triples in the form of Subject - Predicate - Object:

Subject: The entity (e.g., "Elon Musk").

Predicate: The relationship (e.g., "is CEO of").

Object: The value or another entity (e.g., "Tesla").

Unlike a standard database that stores data in rigid tables (Rows/Columns), a Knowledge Graph stores data as a flexible network of connected concepts.

Why is it Important?
Knowledge Graphs are crucial because they allow machines to understand context rather than just matching keywords.

Context & Semantics: It helps computers distinguish between "Jaguar" (the animal) and "Jaguar" (the car) based on the surrounding relationships in the graph.

Data Integration: It bridges the gap between data silos. You can connect unstructured data (text documents) with structured data (SQL databases) into a single network.

Inference & Reasoning: KGs allow systems to infer new knowledge.

Fact 1: Albert Einstein won the Nobel Prize.

Fact 2: The Nobel Prize is a prestigious award.

Inference: Albert Einstein received a prestigious award (even if this is not explicitly stated in a database).

Explainable AI: Unlike "black box" deep learning models, a Knowledge Graph can explain how it reached a conclusion by showing the path of relationships it traversed.

Application Areas of Knowledge Graphs
Knowledge Graphs are the backbone of modern AI and data systems. Here are the most common applications:

1. Search Engines (Semantic Search)

Example: Google’s "Knowledge Panel" (the box on the right side of search results).

Use: When you search for "Leonardo da Vinci," Google doesn't just look for the string of text; it understands he is a Person, an Artist, and is connected to Mona Lisa.

2. Recommendation Systems

Example: Netflix, Spotify, Amazon.

Use: If you watched "Inception," the system recommends "Interstellar" not just because other users liked it, but because the Knowledge Graph knows both nodes are connected to the node "Christopher Nolan" (Director).

3. Fraud Detection (Finance)

Example: Banking and Insurance.

Use: Detecting money laundering rings. A graph can reveal that distinct accounts are actually connected through a shared phone number, address, or circular transfer pattern that traditional SQL queries might miss.

4. Healthcare & Drug Discovery

Example: AstraZeneca, Pfizer.

Use: Mapping relationships between Proteins, Diseases, Drugs, and Genes. It helps researchers predict how a new drug might interact with a specific protein structure.

5. Chatbots and Virtual Assistants

Example: Siri, Alexa, Customer Service Bots.

Use: To answer questions like "Who is the president of France?", the bot queries a Knowledge Graph to traverse the relationship: France -> has_president -> Emmanuel Macron

###Building a KG using NetworkX package.
"""

import networkx as nx
import matplotlib.pyplot as plt

# --- 1. EXPANDED DATASET (TRIPLES) ---
# We getting the data set from GenAI:
# Format: (Subject, Relation, Object)
kg_data = [
    # --- DIRECTORS & MOVIES ---
    # Christopher Nolan Filmography
    ("Memento", "directed_by", "Christopher Nolan"),
    ("Insomnia", "directed_by", "Christopher Nolan"),
    ("Batman Begins", "directed_by", "Christopher Nolan"),
    ("The Prestige", "directed_by", "Christopher Nolan"),
    ("The Dark Knight", "directed_by", "Christopher Nolan"),
    ("Inception", "directed_by", "Christopher Nolan"),
    ("The Dark Knight Rises", "directed_by", "Christopher Nolan"),
    ("Interstellar", "directed_by", "Christopher Nolan"),
    ("Dunkirk", "directed_by", "Christopher Nolan"),
    ("Tenet", "directed_by", "Christopher Nolan"),
    ("Oppenheimer", "directed_by", "Christopher Nolan"),

    # Other Directors (for connection variety)
    ("Man of Steel", "directed_by", "Zack Snyder"),
    ("The Lion King", "directed_by", "Roger Allers"),
    ("Dune", "directed_by", "Denis Villeneuve"),

    # --- PRODUCTION / WRITING ---
    ("Man of Steel", "produced_by", "Christopher Nolan"),
    ("The Dark Knight", "written_by", "Jonathan Nolan"),
    ("Interstellar", "written_by", "Jonathan Nolan"),
    ("Westworld", "created_by", "Jonathan Nolan"),

    # --- ACTORS & MOVIES (The "Nolan Regulars" and connections) ---
    # Michael Caine (The most frequent collaborator)
    ("Michael Caine", "acted_in", "Batman Begins"),
    ("Michael Caine", "acted_in", "The Dark Knight"),
    ("Michael Caine", "acted_in", "The Prestige"),
    ("Michael Caine", "acted_in", "Inception"),
    ("Michael Caine", "acted_in", "The Dark Knight Rises"),
    ("Michael Caine", "acted_in", "Interstellar"),
    ("Michael Caine", "acted_in", "Dunkirk"),
    ("Michael Caine", "acted_in", "Tenet"),

    # Cillian Murphy
    ("Cillian Murphy", "acted_in", "Batman Begins"),
    ("Cillian Murphy", "acted_in", "The Dark Knight"),
    ("Cillian Murphy", "acted_in", "Inception"),
    ("Cillian Murphy", "acted_in", "Dunkirk"),
    ("Cillian Murphy", "acted_in", "Oppenheimer"),
    ("Cillian Murphy", "acted_in", "Peaky Blinders"),

    # Christian Bale
    ("Christian Bale", "acted_in", "Batman Begins"),
    ("Christian Bale", "acted_in", "The Dark Knight"),
    ("Christian Bale", "acted_in", "The Dark Knight Rises"),
    ("Christian Bale", "acted_in", "The Prestige"),

    # Tom Hardy
    ("Tom Hardy", "acted_in", "Inception"),
    ("Tom Hardy", "acted_in", "The Dark Knight Rises"),
    ("Tom Hardy", "acted_in", "Dunkirk"),
    ("Tom Hardy", "acted_in", "Peaky Blinders"),

    # Anne Hathaway
    ("Anne Hathaway", "acted_in", "The Dark Knight Rises"),
    ("Anne Hathaway", "acted_in", "Interstellar"),

    # Other Key Actors
    ("Leonardo DiCaprio", "acted_in", "Inception"),
    ("Matthew McConaughey", "acted_in", "Interstellar"),
    ("Hugh Jackman", "acted_in", "The Prestige"),
    ("Heath Ledger", "acted_in", "The Dark Knight"),
    ("Gary Oldman", "acted_in", "Batman Begins"),
    ("Gary Oldman", "acted_in", "The Dark Knight"),
    ("Gary Oldman", "acted_in", "Oppenheimer"),
    ("Robert Pattinson", "acted_in", "Tenet"),
    ("Kenneth Branagh", "acted_in", "Dunkirk"),
    ("Kenneth Branagh", "acted_in", "Tenet"),
    ("Kenneth Branagh", "acted_in", "Oppenheimer"),
    ("Matt Damon", "acted_in", "Interstellar"),
    ("Matt Damon", "acted_in", "Oppenheimer"),
    ("Zendaya", "acted_in", "Dune"),
    ("Timothée Chalamet", "acted_in", "Dune"),
    ("Timothée Chalamet", "acted_in", "Interstellar"),

    # --- COMPOSERS ---
    # Hans Zimmer (The legend)
    ("Hans Zimmer", "composed_music_for", "Batman Begins"),
    ("Hans Zimmer", "composed_music_for", "The Dark Knight"),
    ("Hans Zimmer", "composed_music_for", "The Dark Knight Rises"),
    ("Hans Zimmer", "composed_music_for", "Inception"),
    ("Hans Zimmer", "composed_music_for", "Interstellar"),
    ("Hans Zimmer", "composed_music_for", "Dunkirk"),
    ("Hans Zimmer", "composed_music_for", "The Lion King"), # External connection
    ("Hans Zimmer", "composed_music_for", "Man of Steel"),
    ("Hans Zimmer", "composed_music_for", "Dune"),

    # Ludwig Göransson
    ("Ludwig Göransson", "composed_music_for", "Tenet"),
    ("Ludwig Göransson", "composed_music_for", "Oppenheimer"),

    # David Julyan
    ("David Julyan", "composed_music_for", "Memento"),
    ("David Julyan", "composed_music_for", "The Prestige"),

    # --- GENRES ---
    ("Memento", "genre", "Thriller"),
    ("Insomnia", "genre", "Thriller"),
    ("Batman Begins", "genre", "Action"),
    ("The Dark Knight", "genre", "Action"),
    ("The Dark Knight Rises", "genre", "Action"),
    ("Inception", "genre", "Sci-Fi"),
    ("Interstellar", "genre", "Sci-Fi"),
    ("Tenet", "genre", "Sci-Fi"),
    ("Dune", "genre", "Sci-Fi"),
    ("Dunkirk", "genre", "War"),
    ("Oppenheimer", "genre", "Biography"),
    ("The Prestige", "genre", "Drama"),
    ("Peaky Blinders", "genre", "Drama"),

    # --- FRANCHISE / SEQUEL RELATIONS ---
    ("The Dark Knight", "is_sequel_to", "Batman Begins"),
    ("The Dark Knight Rises", "is_sequel_to", "The Dark Knight"),

    # --- LOCATIONS / ORIGINS ---
    ("Christopher Nolan", "born_in", "London"),
    ("Tom Hardy", "born_in", "London"),
    ("Michael Caine", "born_in", "London"),
    ("Christian Bale", "born_in", "Wales"),
    ("Cillian Murphy", "born_in", "Ireland"),
    ("Hans Zimmer", "born_in", "Germany"),
    ("London", "located_in", "UK"),
    ("Wales", "located_in", "UK")
]

# --- 2. BUILDING THE GRAPH ---
G = nx.DiGraph()

for subject, relation, obj in kg_data:
    G.add_edge(subject, obj, relation=relation)
# --- 3. IMPROVED STATIC VISUALIZATION ---
plt.figure(figsize=(24, 18))  # 1. Tuvali çok daha büyük yapın


pos = nx.spring_layout(G, k=0.30, iterations=50, seed=42)


relation_color_map = {
    "directed_by": "tab:red", "acted_in": "tab:blue", "genre": "tab:green",
    "composed_music_for": "tab:purple", "born_in": "tab:orange",
    "located_in": "tab:orange", "is_a": "gray", "produced_by": "brown",
    "written_by": "brown", "created_by": "brown", "is_sequel_to": "black"
}
edge_colors = [relation_color_map.get(G[u][v]['relation'], 'black') for u, v in G.edges()]


nx.draw_networkx_nodes(G, pos, node_size=1000, node_color='lightblue', alpha=0.9)
nx.draw_networkx_edges(G, pos, width=1.5, alpha=0.6, edge_color=edge_colors, arrowsize=15)
nx.draw_networkx_labels(G, pos, font_size=8, font_weight="bold") # Font küçüldü



edge_labels = nx.get_edge_attributes(G, 'relation')
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=6, font_color='red')

# Legend
import matplotlib.patches as mpatches
legend_patches = [mpatches.Patch(color=color, label=rel) for rel, color in relation_color_map.items()]
plt.legend(handles=legend_patches, loc='upper left', title="Relations")

plt.title(" Knowledge Graph", fontsize=20)
plt.axis('off')
plt.show()

# --- 4. QUERYING AND REASONING ---
print("\n--- Knowledge Graph Analysis ---")

# Question 1: What is the common ground between Cillian Murphy and Leonardo DiCaprio?
# Logic: Find the common node that both actors are connected to via 'acted_in'.
person1 = "Cillian Murphy"
person2 = "Leonardo DiCaprio"

# G.successors(node) -> nodes that 'node' points to.
print(f"\n1. Common connection between {person1} and {person2}:")
common_projects = set(G.successors(person1)) & set(G.successors(person2))
for project in common_projects:
    print(f"   -> Both acted in '{project}'.")

# Question 2: Who composed the music for Christopher Nolan's movies?
# Logic: Find movies directed by Nolan -> Find composers of those movies.
target_director = "Christopher Nolan"
print(f"\n2. Who are the composers for {target_director}'s movies?")

# We iterate through the graph to match the pattern: Composer -> Movie -> Director
for node in G.nodes():
    # Check if the node is a composer (has an outgoing 'composed_music_for' edge)
    if any(G[node][nbr]['relation'] == "composed_music_for" for nbr in G.successors(node)):
        composer = node
        # Look at the movies the composer worked on
        for movie in G.successors(composer):
            # Check if the movie was directed by our target director
            if target_director in G.successors(movie):
                print(f"   -> {composer} composed for '{movie}' (Director: {target_director})")

# Question 3: Which actors have been in a project with music by Hans Zimmer?
# Logic: Hans Zimmer -> Music for Movie <- Actor acted in
print(f"\n3. Actors in projects scored by Hans Zimmer:")
composer = "Hans Zimmer"
if composer in G:
    for movie in G.successors(composer): # Movies by Zimmer
        # Since arrows go Actor -> Movie, we look at 'predecessors' of the movie node
        for actor in G.predecessors(movie):
            relation = G[actor][movie]['relation']
            if relation == "acted_in":
                print(f"   -> {actor} (in '{movie}')")